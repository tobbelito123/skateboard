<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Falling Letters with Realistic Physics</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000; /* Dark background */
    }
    canvas {
      display: block;
      background-color: #000;
    }
  </style>
  <!-- Load Matter.js from unpkg -->
  <script src="https://unpkg.com/matter-js@0.19.0/build/matter.min.js"></script>
  <!-- Load poly-decomp from unpkg -->
  <script src="https://unpkg.com/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <!-- Load opentype.js from unpkg -->
  <script src="https://unpkg.com/opentype.js@1.3.4/dist/opentype.min.js"></script>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // --- Set up Matter.js ---
    const Engine = Matter.Engine,
          World = Matter.World,
          Bodies = Matter.Bodies,
          Body = Matter.Body,
          Composite = Matter.Composite;
    
    const engine = Engine.create();
    // Use a gravity value that “feels” realistic in our pixel scale.
    engine.world.gravity.y = 1;
    
    // Get canvas and context.
    const canvas = document.getElementById('canvas');
    const context = canvas.getContext('2d');
    
    // Arrays to hold letter bodies.
    const letterBodies = [];
    let boundaries = [];
    
    // Resize canvas and update boundaries.
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      updateBoundaries();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    // Create or update boundaries (floor and side walls).
    function updateBoundaries() {
      // Remove old boundaries.
      boundaries.forEach(b => World.remove(engine.world, b));
      boundaries = [];
      
      const thickness = 100;
      // Floor (extend width for safety)
      const floor = Bodies.rectangle(canvas.width / 2, canvas.height + thickness / 2, canvas.width * 2, thickness, { isStatic: true });
      // Left wall
      const leftWall = Bodies.rectangle(-thickness / 2, canvas.height / 2, thickness, canvas.height * 2, { isStatic: true });
      // Right wall
      const rightWall = Bodies.rectangle(canvas.width + thickness / 2, canvas.height / 2, thickness, canvas.height * 2, { isStatic: true });
      boundaries.push(floor, leftWall, rightWall);
      World.add(engine.world, boundaries);
    }
    
    // --- Helper functions for converting font paths to vertices ---
    // This function approximates quadratic and cubic curves by sampling points.
    function pathToVertices(path, sampleSteps = 10) {
      let vertices = [];
      let currX = 0, currY = 0;
      for (let cmd of path.commands) {
        if (cmd.type === 'M') {
          if (vertices.length > 0) break; // use only the first subpath
          currX = cmd.x;
          currY = cmd.y;
          vertices.push({ x: currX, y: currY });
        } else if (cmd.type === 'L') {
          currX = cmd.x;
          currY = cmd.y;
          vertices.push({ x: currX, y: currY });
        } else if (cmd.type === 'Q') {
          let cpX = cmd.x1, cpY = cmd.y1;
          let endX = cmd.x, endY = cmd.y;
          for (let t = 0; t <= 1; t += 1 / sampleSteps) {
            let x = (1 - t) * (1 - t) * currX + 2 * (1 - t) * t * cpX + t * t * endX;
            let y = (1 - t) * (1 - t) * currY + 2 * (1 - t) * t * cpY + t * t * endY;
            vertices.push({ x, y });
          }
          currX = endX;
          currY = endY;
        } else if (cmd.type === 'C') {
          let cp1X = cmd.x1, cp1Y = cmd.y1;
          let cp2X = cmd.x2, cp2Y = cmd.y2;
          let endX = cmd.x, endY = cmd.y;
          for (let t = 0; t <= 1; t += 1 / sampleSteps) {
            let x = Math.pow(1 - t, 3) * currX +
                    3 * Math.pow(1 - t, 2) * t * cp1X +
                    3 * (1 - t) * t * t * cp2X +
                    Math.pow(t, 3) * endX;
            let y = Math.pow(1 - t, 3) * currY +
                    3 * Math.pow(1 - t, 2) * t * cp1Y +
                    3 * (1 - t) * t * t * cp2Y +
                    Math.pow(t, 3) * endY;
            vertices.push({ x, y });
          }
          currX = endX;
          currY = endY;
        }
      }
      return vertices;
    }
    
    // Compute centroid for a set of vertices.
    function computeCentroid(vertices) {
      let sumX = 0, sumY = 0;
      vertices.forEach(v => {
        sumX += v.x;
        sumY += v.y;
      });
      return { x: sumX / vertices.length, y: sumY / vertices.length };
    }
    
    // --- Rendering and physics update ---
    function render() {
      // Clear canvas.
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = "#000";
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw each letter's shape.
      for (let body of letterBodies) {
        if (!body.customPath) continue;
        context.save();
        context.translate(body.position.x, body.position.y);
        context.rotate(body.angle);
        // Offset the drawing so that the shape is centered.
        context.translate(-body.customCentroid.x, -body.customCentroid.y);
        context.fillStyle = "white";
        context.fill(body.customPath);
        context.restore();
      }
    }
    
    function animate() {
      Engine.update(engine, 16.66); // roughly 60 fps
      render();
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    
    // --- Load a font using opentype.js ---
    // Using Roboto-Regular TTF from raw.githack.com
    const fontURL = "https://raw.githack.com/google/fonts/main/apache/roboto/Roboto-Regular.ttf";
    let loadedFont = null;
    
    opentype.load(fontURL, function(err, font) {
      if (err) {
        console.error('Could not load font: ' + err);
      } else {
        loadedFont = font;
        // Start spawning letters once the font is loaded.
        setInterval(spawnLetter, 1000);
      }
    });
    
    // --- Spawn a random letter at the top ---
    function spawnLetter() {
      if (!loadedFont) return;
      // Choose a random letter A-Z.
      const letter = String.fromCharCode(Math.floor(Math.random() * 26) + 65);
      // Random font size between 20 and 80 pixels.
      const fontSize = Math.random() * 60 + 20;
      
      // Get the font path at (0,0).
      let path = loadedFont.getPath(letter, 0, 0, fontSize);
      // Convert the path to vertices.
      let verts = pathToVertices(path, 10);
      if (verts.length < 3) return;
      
      // Compute and adjust for centroid.
      let centroid = computeCentroid(verts);
      let adjustedVerts = verts.map(v => ({ x: v.x - centroid.x, y: v.y - centroid.y }));
      
      // Choose a random x position at the top.
      const spawnX = Math.random() * (canvas.width - fontSize) + fontSize / 2;
      const spawnY = -fontSize;
      
      // Options: add air friction and restitution.
      const options = {
        frictionAir: 0.05,
        restitution: 0.2,
        density: 1
      };
      
      let body;
      try {
        body = Bodies.fromVertices(spawnX, spawnY, [adjustedVerts], options, true);
      } catch (e) {
        console.error("Failed to create body for letter", letter, e);
        return;
      }
      if (!body) return;
      
      // Create a Path2D for rendering.
      let centeredPath = loadedFont.getPath(letter, -centroid.x, -centroid.y, fontSize);
      let pathData = centeredPath.toPathData();
      body.customPath = new Path2D(pathData);
      body.customCentroid = centroid;
      body.letter = letter;
      
      World.add(engine.world, body);
      letterBodies.push(body);
    }
  </script>
</body>
</html>
